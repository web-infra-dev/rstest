export type BrowserLocatorText =
  | { type: 'string'; value: string }
  | { type: 'regexp'; source: string; flags?: string };

export type BrowserLocatorStep =
  | {
      type: 'getByRole';
      role: string;
      options?: {
        name?: BrowserLocatorText;
        exact?: boolean;
        checked?: boolean;
        disabled?: boolean;
        expanded?: boolean;
        selected?: boolean;
        pressed?: boolean;
        includeHidden?: boolean;
        level?: number;
      };
    }
  | {
      type: 'locator';
      selector: string;
    }
  | {
      type: 'getByText';
      text: BrowserLocatorText;
      options?: { exact?: boolean };
    }
  | {
      type: 'getByLabel';
      text: BrowserLocatorText;
      options?: { exact?: boolean };
    }
  | {
      type: 'getByPlaceholder';
      text: BrowserLocatorText;
      options?: { exact?: boolean };
    }
  | {
      type: 'getByAltText';
      text: BrowserLocatorText;
      options?: { exact?: boolean };
    }
  | {
      type: 'getByTitle';
      text: BrowserLocatorText;
      options?: { exact?: boolean };
    }
  | {
      type: 'getByTestId';
      text: BrowserLocatorText;
    }
  | {
      type: 'filter';
      options: {
        hasText?: BrowserLocatorText;
        hasNotText?: BrowserLocatorText;
        has?: BrowserLocatorIR;
        hasNot?: BrowserLocatorIR;
      };
    }
  | { type: 'and'; locator: BrowserLocatorIR }
  | { type: 'or'; locator: BrowserLocatorIR }
  | { type: 'nth'; index: number }
  | { type: 'first' }
  | { type: 'last' };

export type BrowserLocatorIR = {
  steps: BrowserLocatorStep[];
};

export type BrowserRpcRequest = {
  id: string;
  /** Absolute test file path for locating runner iframe */
  testPath: string;
  /** Run identifier generated by container for stale-request protection. */
  runId: string;
  kind: 'locator' | 'expect' | 'config';
  locator: BrowserLocatorIR;
  method: string;
  args: unknown[];
  /**
   * Negation for expect matchers (equivalent to Playwright expect(...).not).
   * Only meaningful for kind === 'expect'.
   */
  isNot?: boolean;
  /** Optional timeout override (ms). Falls back to browser rpcTimeout. */
  timeout?: number;
};

const isRecord = (value: unknown): value is Record<string, unknown> => {
  return typeof value === 'object' && value !== null;
};

const readString = (
  value: Record<string, unknown>,
  key: string,
  label: string,
): string => {
  const result = value[key];
  if (typeof result !== 'string') {
    throw new Error(`Invalid browser RPC request: ${label} must be a string`);
  }
  return result;
};

const readUnknownArray = (
  value: Record<string, unknown>,
  key: string,
  label: string,
): unknown[] => {
  const result = value[key];
  if (!Array.isArray(result)) {
    throw new Error(`Invalid browser RPC request: ${label} must be an array`);
  }
  return result;
};

const parseBrowserLocatorIR = (
  value: unknown,
  label: string,
): BrowserLocatorIR => {
  if (!isRecord(value)) {
    throw new Error(`Invalid browser RPC request: ${label} must be an object`);
  }

  const steps = value.steps;
  if (!Array.isArray(steps)) {
    throw new Error(
      `Invalid browser RPC request: ${label}.steps must be an array`,
    );
  }

  return value as BrowserLocatorIR;
};

export const validateBrowserRpcRequest = (
  payload: unknown,
): BrowserRpcRequest => {
  if (!isRecord(payload)) {
    throw new Error('Invalid browser RPC request: payload must be an object');
  }

  const kind = readString(payload, 'kind', 'kind');
  if (kind !== 'locator' && kind !== 'expect' && kind !== 'config') {
    throw new Error(
      `Invalid browser RPC request: unsupported kind ${JSON.stringify(kind)}`,
    );
  }

  const request: BrowserRpcRequest = {
    id: readString(payload, 'id', 'id'),
    testPath: readString(payload, 'testPath', 'testPath'),
    runId: readString(payload, 'runId', 'runId'),
    kind,
    locator: parseBrowserLocatorIR(payload.locator, 'locator'),
    method: readString(payload, 'method', 'method'),
    args: readUnknownArray(payload, 'args', 'args'),
  };

  const isNot = payload.isNot;
  if (isNot !== undefined) {
    if (typeof isNot !== 'boolean') {
      throw new Error('Invalid browser RPC request: isNot must be a boolean');
    }
    request.isNot = isNot;
  }

  const timeout = payload.timeout;
  if (timeout !== undefined) {
    if (typeof timeout !== 'number') {
      throw new Error('Invalid browser RPC request: timeout must be a number');
    }
    request.timeout = timeout;
  }

  return request;
};

export type BrowserRpcResponse = {
  id: string;
  result?: unknown;
  error?: string;
};

/**
 * Snapshot RPC request from runner iframe.
 * The container will forward these to the host via WebSocket RPC.
 */
export type SnapshotRpcRequest =
  | {
      id: string;
      method: 'resolveSnapshotPath';
      args: { testPath: string };
    }
  | {
      id: string;
      method: 'readSnapshotFile';
      args: { filepath: string };
    }
  | {
      id: string;
      method: 'saveSnapshotFile';
      args: { filepath: string; content: string };
    }
  | {
      id: string;
      method: 'removeSnapshotFile';
      args: { filepath: string };
    };

/**
 * Snapshot RPC response from container to runner iframe.
 */
export type SnapshotRpcResponse = {
  id: string;
  result?: unknown;
  error?: string;
};
