import { RsbuildDocBadge } from '@components/RsbuildDocBadge';

# output

## output.module <RsbuildDocBadge path="/config/output/module" text="output.module" />

- **类型：** `boolean`
- **默认值：** `true`

是否以 ES 模块格式输出 JavaScript 文件。

Rstest 默认会以 ES 模块格式输出并执行测试代码。如果你希望以 CommonJS 格式输出测试代码，可以通过如下配置项开启：

```ts title="rstest.config.ts"
import { defineConfig } from '@rstest/core';

export default defineConfig({
  output: {
    module: false,
  },
});
```

### Commonjs interop

当你以 ES 模块格式输出 JavaScript 文件时（`output.module: true`），Rstest 会默认根据依赖的引用方式来判断 external 的类型：

- 通过 `import` 语法引用的依赖会被视为 ES 模块类型的 external。
- 通过 `require` 语法引用的依赖会被视为 CommonJS 的 external。

当你通过 import 语法引用 CommonJS 模块时，Rstest 会尝试进行 interop 处理，使得你可以通过 `import` 语法正常引用 CommonJS 模块的导出。以下代码在 rstest 中可以正常工作：

```ts title="cjs-module"
Object.defineProperty(exports, '__esModule', { value: true });

const a = require('./a');

exports.a = a.a;

exports.default = () => {
  return `hello ${a.a}`;
};
```

```ts title="test/index.test.ts"
import defaultExport, { a } from 'cjs-module'; // ✅
```

然而，这种 interop 处理并不总是完美的，具体取决于被引用的 CommonJS 模块的导出方式。目前 Rstest 还不支持将 CommonJS 模块的 default 导出作为命名导出进行 interop。

```ts
function lodash(_value) {}

lodash.VERSION = VERSION;

module.exports = lodash;
```

```ts
import { VERSION } from 'lodash'; // ❌
```

如果你在使用过程中遇到问题，可以通过 [指定 external 类型](#指定-external-类型) 的方式来指定某个依赖的 external 类型为 CommonJS。

```ts title="rstest.config.ts"
import { defineConfig } from '@rstest/core';

export default defineConfig({
  output: {
    externals: {
      lodash: 'commonjs lodash', // 将 lodash 作为 CommonJS 模块进行 external
    },
  },
});
```

## output.externals <RsbuildDocBadge path="/config/output/externals" text="output.externals" />

配置代码中的某些 `import` 的依赖不被打包，而是由 Rstest 在运行时去获取这些依赖。

- 在 Node.js 测试环境中，默认打包：
  - 任意目录下的 TypeScript 和 JSX 文件，匹配的文件后缀为 `.ts`、`.tsx`、`.jsx`、`.mts`、`.cts`。
  - 非 `node_modules` 目录下的 JavaScript 文件，匹配的文件后缀为 `.js`、`.mjs`、`.cjs`。
- 在类浏览器（jsdom 等）测试环境中，默认打包所有依赖。

如果你想某个依赖不被打包，可以在 `output.externals` 中进行配置。

```ts title="rstest.config.ts"
import { defineConfig } from '@rstest/core';

export default defineConfig({
  output: {
    externals: ['react'],
  },
});
```

如果你希望所有依赖都被打包，可以通过如下配置：

```ts title="rstest.config.ts"
import { defineConfig } from '@rstest/core';

export default defineConfig({
  tools: {
    rspack: (config) => {
      config.externals = [];
    },
  },
});
```

### 指定 external 类型

你可以通过 `${externalsType} ${libraryName}` 语法来指定某个依赖的 external 类型。

```ts title="rstest.config.ts"
import { defineConfig } from '@rstest/core';

export default defineConfig({
  output: {
    externals: {
      lodash: 'commonjs lodash', // 将 lodash 作为 CommonJS 模块进行 external
    },
  },
});
```

你也可以通过 [`externalsType` 配置项](https://rspack.rs/config/externals#externalstype) 来指定所有依赖的默认 external 类型。

```ts title="rstest.config.ts"
import { defineConfig } from '@rstest/core';

export default defineConfig({
  tools: {
    rspack: {
      externalsType: 'commonjs',
    },
  },
});
```

## output.cssModules <RsbuildDocBadge path="/config/output/css-modules" text="output.cssModules" />

用于自定义 CSS Modules 的配置。

## output.cleanDistPath <RsbuildDocBadge path="/config/output/clean-dist-path" text="output.cleanDistPath" />

是否在测试开始前，清空输出目录下的所有测试临时文件。

默认情况下，Rstest 不会将测试临时文件写入磁盘，当你开启 Rstest 产物调试时可能需要此配置项。
