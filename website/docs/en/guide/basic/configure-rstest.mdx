# Configure Rstest

## Configuration file

When you use the CLI of Rstest, Rstest will automatically read the configuration file in the root directory of the current project and resolve it in the following order:

- `rstest.config.mjs`
- `rstest.config.ts`
- `rstest.config.js`
- `rstest.config.cjs`
- `rstest.config.mts`
- `rstest.config.cts`

We recommend using the `.mjs` or `.ts` format for the configuration file and importing the `defineConfig` utility function from `@rstest/core`. It provides friendly TypeScript type hints and autocompletion, which can help you avoid errors in the configuration.

```ts title="rstest.config.ts"
import { defineConfig } from '@rstest/core';

export default defineConfig({
  testEnvironment: 'node',
});
```

If you are developing a non-TypeScript project, you can use the `.mjs` format for the configuration file.

### Specify config file

Rstest CLI uses the `--config` option to specify the config file, which can be set to a relative path or an absolute path.

```json title="package.json"
{
  "scripts": {
    "test": "rstest --config scripts/rstest.config.mjs"
  }
}
```

You can also abbreviate the `--config` option to `-c`:

```bash
rstest -c scripts/rstest.config.mjs
```

## Configure Rsbuild

Rstest's build configuration inherits from Rsbuild. Therefore, in Rstest, you can use most of the Rsbuild configurations, such as:

- Using Rsbuild plugins through [plugins](/config/#plugins);
- Configuring module resolution behavior through [resolve](/config/build/resolve);
- Configuring Rspack through [tools.rspack](/config/build/tools#toolsrspack);
- Configuring builtin:swc-loader through [tools.swc](/config/build/tools#toolsswc).

More configurations can be referred to [Build Configurations](/config/#build-configurations).

## Configure Rspack

Rstest uses Rspack for building, so you can directly use Rspack's configuration options to configure Rstest's build behavior.

More details can be referred to [Configure Rspack](https://rsbuild.rs/guide/configuration/rspack).

## Configure SWC

Rstest uses Rspack's [builtin:swc-loader](https://rspack.rs/guide/features/builtin-swc-loader) to transform JavaScript and TypeScript code by default, which is the Rust version of [swc-loader](https://github.com/swc-project/pkgs/tree/main/packages/swc-loader).

Rstest exposes some options to configure `builtin:swc-loader`:

- [tools.swc](/config/build/tools#toolsswc): Used to configure the options of `builtin:swc-loader`.
- [source.include](/config/build/source#sourceinclude): Used to specify the files that need to be compiled by SWC.
- [source.exclude](/config/build/source#sourceexclude): Used to exclude files that do not need to be compiled by SWC.

```ts
import { defineConfig } from '@rsbuild/core';

export default defineConfig({
  tools: {
    swc: {
      jsc: {
        transform: {
          react: {
            runtime: 'automatic',
          },
        },
        experimental: {
          plugins: [['@swc/plugin-emotion', {}]],
        },
      },
    },
  },
});
```

### SWC plugin version

Please note that SWC's plugins are still an experimental feature. Currently, SWC's Wasm plugins are not backward compatible, and the version of SWC plugins is strongly coupled with the `swc_core` version that Rspack depends on.

This means that you need to choose SWC plugins that match the current `swc_core` version to make them work properly. If the SWC plugin version you use does not match the `swc_core` version that Rspack depends on, Rspack will throw errors during the build. Please refer to [Rspack FAQ - SWC plugin version mismatch](https://rspack.rs/errors/swc-plugin-version) for handling.

## Detect Rstest environment

You can use `process.env.RSTEST` to detect whether it is an Rstest test environment to apply different configurations/codes in your tests.

```ts
if (process.env.RSTEST) {
  // 'true' will be returned in the rstest environment
  // do something...
}
```

It should be noted that if you use `process.env.RSTEST` in your source code, define `process.env.RSTEST` as `false` in your build configuration (such as `rsbuild.config.ts`) during production builds, this will help the bundler eliminate dead code.

```diff title=rsbuild.config.ts
import { defineConfig } from '@rsbuild/core';

export default defineConfig({
  source: {
    define: {
+      'process.env.RSTEST': false,
    },
  },
});
```

If you are developing the Rsbuild plugin, you can use [api.context.callerName](https://rsbuild.rs/api/javascript-api/instance#contextcallername) to determine the current plugin is being called.

```ts
export const myPlugin = {
  name: 'my-plugin',
  setup(api) {
    const { callerName } = api.context;

    if (callerName === 'rstest') {
      // ...
    } else if (callerName === 'rsbuild') {
      // ...
    }
  },
};
```
